using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FastEnumToString
{
    /// <summary>
    /// <hr/>
    /// Generates a <em>FastToString</em> method for each enum in the referencing assembly.<br />
    /// From <see cref="ISourceGenerator"/>:<br />
    /// <inheritdoc/>
    /// </summary>
    [Generator]
    public class EnumToStringGenerator : ISourceGenerator
    {
        #region Private Members
        #region Diagnostic Descriptors
        private static readonly DiagnosticDescriptor Error =
            new DiagnosticDescriptor(
                id: "ETSG001",
                title: "An error has occured while generating enum extensions",
                messageFormat: "An error has occured while generationg source for enum extensions for {0}.{1}",
                category: "Compilation",
                defaultSeverity: DiagnosticSeverity.Error,
                isEnabledByDefault: true);

        private static readonly DiagnosticDescriptor Success =
            new DiagnosticDescriptor(
                id: "ETSG002",
                title: "Successfully generated enum extensions",
                messageFormat: "Successfully generated source for enum extensions with name {0}.{1}",
                category: "Compilation",
                defaultSeverity: DiagnosticSeverity.Info,
                isEnabledByDefault: true);
        #endregion

        private const string GeneratedFileName = "EnumStringConverter.g.cs";
        private const string AutoGenComment = "// <auto-generated />\r\n\r\n";
        private const string NoContentComment = "    // Code will be generated here.\r\n";
        private const string UsingTemplate = "using {0};\r\n";
        private const string ClassStart = "\r\npublic static class EnumStringConverter\r\n{";
        private const string MethodDeclaration = "\r\n    {0} static string FastToString(this {1} enumValue)";
        private const string BodyNSwitchStart = "\r\n    {\r\n        return enumValue switch\r\n        {\r\n";
        private const string SwicthArm = "            {0}.{1} => nameof({0}.{1}),\r\n";
        private const string SwitchNBodyEnd = "            _ => throw new ArgumentOutOfRangeException(nameof(enumValue), enumValue, null)\r\n        };\r\n    }";
        private static readonly string GeneratedCodeAttr =
            $"\r\n[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"{nameof(FastEnumToString)}.{nameof(EnumToStringGenerator)}\", \"{Assembly.Version}\")]";
        #endregion

        /// <inheritdoc/>
        public void Initialize(GeneratorInitializationContext context)
        {
#if DEBUG
            //if (!System.Diagnostics.Debugger.IsAttached)
            //{
            //    System.Diagnostics.Debugger.Launch();
            //}
#endif
            context.RegisterForSyntaxNotifications(() => new EnumToStringSyntaxReciever());
        }
        
        /// <inheritdoc/>
        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is EnumToStringSyntaxReciever reciever))
            {
                return;
            }

            string generatedClass = reciever.FoundEnums.Count == 0
                ? $"{AutoGenComment}{GeneratedCodeAttr}{ClassStart}{NoContentComment}}}"
                : ProcessEnums(context, reciever.FoundEnums);

            context.ReportDiagnostic(Diagnostic.Create(Success, Location.None));
            context.AddSource(GeneratedFileName, generatedClass);
        }

        /// <summary>
        /// Processes the collected enum and generates the extension methods for them.
        /// </summary>
        /// <param name="context">The generator context in which the enums are located and where the source should be added</param>
        /// <param name="enums">The collection of found enums</param>
        /// <returns>The generated static class in which the extension methods are located</returns>
        private static string ProcessEnums(GeneratorExecutionContext context, ICollection<EnumDeclarationSyntax> enums)
        {
            // placeholder eg.: {0}; length: 3
            int methodLengthEstimation = (
                BodyNSwitchStart.Length
                + SwitchNBodyEnd.Length
                + MethodDeclaration.Length
                // estimated average length of enum names (16),
                // estimated average length of enum value names (10),
                // longest accessability modifiers (internal) length (8)
                + 18 // 16 + 8 - (2 * placeholder)
                * (SwicthArm.Length + 40) // 2 * 16 + 2 * 10 - 4 * placeholder
                ) * enums.Count;
            // because StringBuilder always uses power of 2 valuesf
            methodLengthEstimation = NextPowOf2(methodLengthEstimation);

            var namespaces = new HashSet<string>();
            var methods = new StringBuilder(methodLengthEstimation);

            foreach (EnumDeclarationSyntax syntax in enums)
            {
                ISymbol symbol = context
                    .Compilation
                    .GetSemanticModel(syntax.SyntaxTree)
                    .GetDeclaredSymbol(syntax, context.CancellationToken);

                namespaces.Add(String.Format(UsingTemplate, symbol.ContainingNamespace));
                string modifier = syntax.Modifiers.Count > 0 ? syntax.Modifiers[0].ToString() : "internal";

                string generatedBody;
                try
                {
                    generatedBody = ProcessEnum(syntax.Members, symbol.Name);
                }
                catch (Exception ex)
                {
                    Location location = Location.Create(syntax.SyntaxTree, syntax.Span);
                    context.ReportDiagnostic(Diagnostic.Create(Error, location, symbol.Name, ex));
                    continue;
                }

                methods
                    .AppendFormat(MethodDeclaration, modifier, symbol.Name)
                    .Append(BodyNSwitchStart)
                    .Append(generatedBody)
                    .AppendLine(SwitchNBodyEnd);

            }

            string usings = String.Join("", namespaces);
            return new StringBuilder(AutoGenComment.Length + usings.Length + GeneratedCodeAttr.Length + ClassStart.Length + methods.Length + 1)
                .Append(AutoGenComment)
                .Append(usings)
                .Append(GeneratedCodeAttr)
                .Append(ClassStart)
                .Append(methods)
                .Append('}')
                .ToString();
        }

        /// <summary>
        /// Generates the extension method body for an enum
        /// </summary>
        /// <param name="enumMembers">Collection of the enum members</param>
        /// <param name="enumName">Name of the enum</param>
        /// <returns>The genrated extension method body</returns>
        private static string ProcessEnum(SeparatedSyntaxList<EnumMemberDeclarationSyntax> enumMembers, string enumName)
        {
            // Since the names length can vary an additional value has been added
            // to get as close as possible to the real length
            int suggestedStartCapacity = enumMembers.Count * (SwicthArm.Length + 40);

            StringBuilder builder = new StringBuilder(suggestedStartCapacity);

            for (int i = 0; i < enumMembers.Count; i++)
            {
                builder.AppendFormat(
                    SwicthArm,
                    enumName,
                    enumMembers[i].Identifier.ToString());
            }

            return builder.ToString();
        }

        /// <summary>
        /// Ceils the given number to the next power of 2 value
        /// </summary>
        /// <param name="number">The number that should be ceiled</param>
        /// <returns>Next power of two</returns>
        private static int NextPowOf2(int number)
        {
            return (int)Math.Pow(2, Math.Ceiling(Math.Log(number) / Math.Log(2)));
        }
    }
}

