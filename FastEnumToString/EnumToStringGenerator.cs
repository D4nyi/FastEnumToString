using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FastEnumToString
{
    [Generator]
    public class EnumToStringGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            List<EnumDeclarationSyntax> enumSyntaxes = context.Compilation.SyntaxTrees
                .Select(x => x.GetRoot().DescendantNodes().OfType<EnumDeclarationSyntax>())
                .Where(x => x.Any())
                .SelectMany(x => x)
                .ToList();

            if (!enumSyntaxes.Any())
            {
                context.AddSource("EnumStringConverter.g.cs", "// <auto-generated />\r\npublic static class EnumStringConverter\r\n{\r\n// Code will be generated here.\r\n}");
                return;
            }

            const string usingTemplate = "using {0};\r\n";
            const string autoGenComment = "// <auto-generated />\r\n\r\n";
            const string classStart = "\r\npublic static class EnumStringConverter\r\n{";
            const string method = "\r\n    {0} static string FastToString(this {1} enumValue)";
            const string bodyNSwitchStart = "\r\n    {\r\n        return enumValue switch\r\n        {\r\n";
            const string switchEnd = "            _ => throw new ArgumentOutOfRangeException(nameof(enumValue), enumValue, null)\r\n        };\r\n    }";

            var namespaces = new StringBuilder();
            var methods = new StringBuilder();

            foreach (EnumDeclarationSyntax enumDeclaration in enumSyntaxes)
            {
                var nameSpaceDeclaratin = enumDeclaration.Parent as BaseNamespaceDeclarationSyntax;
                string enumNamespace = nameSpaceDeclaratin.Name.ToString();

                namespaces.AppendFormat(usingTemplate, enumNamespace);

                string modifier = enumDeclaration.Modifiers.Any() ? enumDeclaration.Modifiers[0].ToString() : "internal";
                string name = enumDeclaration.Identifier.ToString();
                methods
                    .AppendFormat(method, modifier, name)
                    .Append(bodyNSwitchStart)
                    .Append(ProcessEnum(enumDeclaration.Members, name))
                    .AppendLine(switchEnd);
            }

            string generatedClass = new StringBuilder(autoGenComment.Length + namespaces.Length + classStart.Length + methods.Length + 1)
                .Append(autoGenComment)
                .Append(namespaces)
                .Append(classStart)
                .Append(methods)
                .Append('}')
                .ToString();

            // Add the source code to the compilation
            context.AddSource("EnumStringConverter.g.cs", generatedClass);
        }

        public void Initialize(GeneratorInitializationContext context)
        {
//#if DEBUG
//            if (!Debugger.IsAttached)
//            {
//                Debugger.Launch();
//            }
//#endif
        }

        private static string ProcessEnum(SeparatedSyntaxList<EnumMemberDeclarationSyntax> enumMembers, string enumName)
        {
            StringBuilder builder = new StringBuilder();
            const string swicthArm = "            {0}.{1} => nameof({0}.{1}),\r\n";

            foreach (EnumMemberDeclarationSyntax member in enumMembers)
            {
                builder.AppendFormat(swicthArm, enumName, member.Identifier.ToString());
            }

            return builder.ToString();
        }
    }
}

