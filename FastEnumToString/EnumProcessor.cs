using System;
using System.Collections.Generic;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;

namespace FastEnumToString
{
    internal class EnumProcessor
    {
        #region Private Members
        private const string AutoGenComment = "// <auto-generated />\r\n\r\n";
        private const string NoContentComment = "    // Code will be generated here.\r\n";
        private const string UsingTemplate = "using {0};\r\n";
        private const string ClassStart = "\r\npublic static class EnumStringConverter\r\n{";
        private const string MethodDeclaration = "\r\n    {0} static string FastToString(this {1} enumValue)";
        private const string BodyNSwitchStart = "\r\n    {\r\n        return enumValue switch\r\n        {\r\n";
        private const string SwicthArm = "            {0}.{1} => nameof({0}.{1}),\r\n";
        private const string SwitchDefaultThrow = "            _ => throw new global::System.ArgumentOutOfRangeException(nameof(enumValue), enumValue, $\"{nameof(enumValue)} cannot be found in the provided enum type!\")";
        private const string SwitchDefault = "            _ => nameof({0}.{1})";
        private const string BodyEnd = "\r\n        };\r\n    }\r\n";
        private const string GeneratedCodeAttr =
            "\r\n[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"" + nameof(FastEnumToString) + "." + nameof(EnumToStringGenerator) + "\", \"" + Assembly.Version + "\")]";
        #endregion

        private readonly GeneratorExecutionContext _context;
        private readonly HashSet<string> _namespaces = new HashSet<string>();
        public static string Empty => $"{AutoGenComment}// Code will be generated here, yet we found no enums.";

        public FallbackType Fallback { get; set; }
        public bool IncludeFlags { get; set; }

        public EnumProcessor(GeneratorExecutionContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Processes the collected enum and generates the extension methods for them.
        /// </summary>
        /// <param name="context">The generator context in which the enums are located and where the source should be added</param>
        /// <param name="enums">The collection of found enums</param>
        /// <returns>The generated static class in which the extension methods are located</returns>
        public string Process(
            IReadOnlyCollection<EnumDeclarationSyntax> enums,
            IReadOnlyCollection<EnumDeclarationSyntax> flags)
        {
            string enumBodies = ProcessEnum(enums);
            string flagBodies = "";
            if (IncludeFlags)
            {
                flagBodies = ProcessFlags(flags);
            }

            string usings = String.Join("", _namespaces);
            return String.Concat(AutoGenComment,
                                 usings,
                                 GeneratedCodeAttr,
                                 ClassStart,
                                 enumBodies,
                                 flagBodies,
                                 "}");
        }

        private string ProcessEnum(IReadOnlyCollection<EnumDeclarationSyntax> enums)
        {
            var methods = new StringBuilder();

            foreach (EnumDeclarationSyntax @enum in enums)
            {
                ISymbol symbol = _context
                    .Compilation
                    .GetSemanticModel(@enum.SyntaxTree)
                    .GetDeclaredSymbol(@enum, _context.CancellationToken);

                if (symbol.ContainingNamespace.ToString() != "<global namespace>")
                {
                    _ = _namespaces.Add(String.Format(UsingTemplate, symbol.ContainingNamespace));
                }
                string modifier = @enum.Modifiers.Count > 0 ? @enum.Modifiers[0].Text : "internal";

                string generatedBody = CreateBudy(@enum.Members, symbol.Name);

                methods
                    .AppendFormat(MethodDeclaration, modifier, symbol.Name)
                    .Append(BodyNSwitchStart)
                    .Append(generatedBody)
                    .Append(CreateDefaulBranch(@enum.Members, symbol.Name))
                    .Append(BodyEnd);
            }

            return methods.ToString();
        }

        private static string ProcessFlags(IReadOnlyCollection<EnumDeclarationSyntax> enums)
        {
            return "";
        }

        /// <summary>
        /// Generates the extension method body for an enum
        /// </summary>
        /// <param name="enumMembers">Collection of the enum members</param>
        /// <param name="enumName">Name of the enum</param>
        /// <returns>The genrated extension method body</returns>
        private static string CreateBudy(SeparatedSyntaxList<EnumMemberDeclarationSyntax> enumMembers, string enumName)
        {
            StringBuilder builder = new StringBuilder();

            // it's read once instead of in every iteration
            int count = enumMembers.Count;
            for (int i = 0; i < count; i++)
            {
                builder.AppendFormat(
                    SwicthArm,
                    enumName,
                    enumMembers[i].Identifier.Text);
            }

            return builder.ToString();
        }

        private string CreateDefaulBranch(SeparatedSyntaxList<EnumMemberDeclarationSyntax> enumMembers, string enumName)
        {
            if (Fallback == FallbackType.Throw || enumMembers.Count == 0)
            {
                return SwitchDefaultThrow;
            }

            return String.Format(SwitchDefault, enumName, enumMembers[0].Identifier.Text);
        }
    }
}
