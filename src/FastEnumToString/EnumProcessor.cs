using System;

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FastEnumToString
{
    internal sealed class EnumProcessor
    {
        #region Private Members
        private const string SwitchArm = "            {0}.{1} => nameof({0}.{1}),\r\n";
        private const string SwitchDefaultThrow = "            _ => throw new global::System.ArgumentOutOfRangeException(nameof(enumValue), enumValue, $\"Value: '{(int)enumValue}' cannot be found in the provided enum type!\")";
        private const string SwitchDefault = "            _ => nameof({0}.{1})";
        private const string GeneratedCodeAttr = $"[global::System.CodeDom.Compiler.GeneratedCode(\"{nameof(FastEnumToString)}\", \"{Assembly.Version}\")]";

        private const string MethodTemplate = @"
        {0} static string FastToString{1}(this {2} enumValue){3}=> enumValue switch
        {{
{4}
        }};
";
        private const string ClassTemplate = @"// <auto-generated/>

namespace FastEnumToString
{{
    {0}
    public static class EnumStringConverter
    {{{1}    }}
}}";
        #endregion

        private readonly Stack<StringBuilder> _builders = new();

        private readonly CultureInfo _invariant = CultureInfo.InvariantCulture;

        internal EnumToGenerate CreateEnumMetadata(INamedTypeSymbol enumSymbol, EnumDeclarationSyntax enumDeclaration, Compilation compilation, CancellationToken ct)
        {
            // Get the full type name of the enum e.g. Color, 
            // or OuterClass<T>.Colour if it was nested in a generic type (for example)
            string enumName = enumSymbol.ToString();

            // Get all the members in the enum
            IEnumerable<string> enumMembers = enumSymbol.GetMembers()
                .Where(static x => x.Kind == SymbolKind.Field) // filter out ctor
                .Select(static x => x.Name);                    // select only the name of the fields

            List<string> members = new(enumMembers);

            string genericParameters = GenerateGenericTypeParameters(enumSymbol);
            string genericConstaints = GetGenericTypeConstraints(enumDeclaration);

            string modifier = enumDeclaration.Modifiers.Count > 0 ? enumDeclaration.Modifiers[0].Text : "internal";

            AttributeSyntax? toStringAttribute = enumDeclaration.AttributeLists.GetToStringAttribute();
            int overridenDefault = GetToStringArgumentValue(toStringAttribute, compilation, ct);

            return new EnumToGenerate(enumName, modifier, genericParameters, genericConstaints, overridenDefault, members);
        }

        internal string Process(ImmutableArray<EnumToGenerate?> enums, int defaultBehaviour)
        {
            StringBuilder builder = GetStringBuilder();

            foreach (var item in enums)
            {
                builder.Append(CreateBody(item!.Value, defaultBehaviour));
            }

            string @class = String.Format(
                _invariant,
                ClassTemplate,
                GeneratedCodeAttr,
                builder.ToString());

            ReturnStringBuilder(builder);

            return @class;
        }

        private string CreateBody(EnumToGenerate toGenerate, int defaultBehaviour)
        {
            StringBuilder builder = GetStringBuilder();

            foreach (string member in toGenerate.Values)
            {
                builder.AppendFormat(
                    _invariant,
                    SwitchArm,
                    toGenerate.Name,
                    member);
            }

            int defaultBranch = toGenerate.DefaultValue < 0
                ? defaultBehaviour
                : toGenerate.DefaultValue;

            if (defaultBranch == 0)
            {
                builder.Append($"            _ => ((int)enumValue).ToString()");
            }
            else if(defaultBranch == 1)
            {
                builder.AppendFormat(_invariant, SwitchDefault, toGenerate.Name, toGenerate.Values[0]);
            }
            else
            {
                builder.Append(SwitchDefaultThrow);
            }

            string result = builder.ToString();

            ReturnStringBuilder(builder);

            return String.Format(
                _invariant,
                MethodTemplate,
                toGenerate.Modifier, toGenerate.GenericTypeParameters, toGenerate.Name, toGenerate.GenericTypeConstraints, result);
        }

        private static int GetToStringArgumentValue(AttributeSyntax? toStringAttribute, Compilation compilation, CancellationToken ct)
        {
            if (!toStringAttribute.HasAttributeArgument())
            {
                return -2;
            }

            SemanticModel semanticModel = compilation.GetSemanticModel(toStringAttribute!.SyntaxTree);
            AttributeArgumentSyntax overrideArg = toStringAttribute.ArgumentList!.Arguments[0];
            ExpressionSyntax overrideExpr = overrideArg.Expression;
            Optional<object?> routeTemplate = semanticModel.GetConstantValue(overrideExpr, ct);
            if (!routeTemplate.HasValue || routeTemplate.Value is null || !Int32.TryParse(routeTemplate.Value.ToString(), out int overridenDefault))
            {
                return -2;
            }

            return overridenDefault;
        }

        private string GenerateGenericTypeParameters(INamedTypeSymbol enumSymbol)
        {
            INamedTypeSymbol? containingType = enumSymbol.ContainingType;
            if (!containingType.GenericParameterCanBeRetrieved())
            {
                return "";
            }

            ImmutableArray<ITypeSymbol> typeArguments = containingType.TypeArguments;
            if (typeArguments.Length == 1)
            {
                return $"<{typeArguments[0].Name}>";
            }

            StringBuilder sb = GetStringBuilder();

            sb.Append('<');

            foreach (ITypeSymbol type in typeArguments)
            {
                sb.Append(type.Name).Append(", ");
            }

            sb.Remove(sb.Length - 2, 2).Append('>');

            string result = sb.ToString();

            ReturnStringBuilder(sb);

            return result;
        }

        private string GetGenericTypeConstraints(EnumDeclarationSyntax enumDeclaration)
        {
            const int maxDepth = 3;
            int i = 0;
            SyntaxNode? parentDeclaration = enumDeclaration.Parent;
            while (parentDeclaration is not ClassDeclarationSyntax && i < maxDepth)
            {
                parentDeclaration = parentDeclaration?.Parent;
                i++;
            }

            if (parentDeclaration is null)
            {
                return " ";
            }

            ClassDeclarationSyntax classDeclaration = (ClassDeclarationSyntax)parentDeclaration;

            string constraints = classDeclaration.ConstraintClauses.ToString();

            if (String.IsNullOrEmpty(constraints))
            {
                return " ";
            }

            string[] constraintsArr = constraints.Split(new string[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);

            if (constraintsArr.Length == 1)
            {
                return $" {constraints} ";
            }

            StringBuilder sb = GetStringBuilder().AppendLine();
            const string constraintsIndent = "            ";
            const string switchIndent = "        ";
            
            foreach (string constraint in constraintsArr.Select(static x => x.Trim()))
            {
                sb.Append(constraintsIndent).AppendLine(constraint);
            }

            sb.Append(switchIndent);

            string result = sb.ToString();

            ReturnStringBuilder(sb);

            return result;
        }

        // Borrowed from: https://github.com/davidfowl/LoggingGenerator/blob/939125e726d4b67cfb827c36dbbbaefea767fb69/Microsoft.Extensions.Logging.Generators/LoggingGenerator.cs#L346
        // our own cheezy object pool since we can't use the .NET core version
        private StringBuilder GetStringBuilder()
        {
            if (_builders.Count == 0)
            {
                return new StringBuilder(1024);
            }

            var b = _builders.Pop();
            b.Clear();
            return b;
        }

        private void ReturnStringBuilder(StringBuilder sb)
        {
            _builders.Push(sb);
        }
    }
}
